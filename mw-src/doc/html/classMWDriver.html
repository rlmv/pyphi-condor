<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MW: MWDriver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MW
   &#160;<span id="projectnumber">0.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classMWDriver-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MWDriver Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="MWDriver_8h_source.html">MWDriver.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5e0110a01075a9dfd3e93053b22f9ef0"><td class="memItemLeft" align="right" valign="top"><a id="a5e0110a01075a9dfd3e93053b22f9ef0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a5e0110a01075a9dfd3e93053b22f9ef0">MWDriver</a> ()</td></tr>
<tr class="memdesc:a5e0110a01075a9dfd3e93053b22f9ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:a5e0110a01075a9dfd3e93053b22f9ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b1dac7d50ff571c480ff386e6fcb30"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a05b1dac7d50ff571c480ff386e6fcb30">~MWDriver</a> ()</td></tr>
<tr class="separator:a05b1dac7d50ff571c480ff386e6fcb30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9140329e1c6a2b4b7f1a0a9a365cab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a7e9140329e1c6a2b4b7f1a0a9a365cab">go</a> (int argc, char *argv[])</td></tr>
<tr class="separator:a7e9140329e1c6a2b4b7f1a0a9a365cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3d2d8a2fac34f02c0573fabb29f1cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a4d3d2d8a2fac34f02c0573fabb29f1cf">go</a> ()</td></tr>
<tr class="separator:a4d3d2d8a2fac34f02c0573fabb29f1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147074c64c2bf0883077a28432816947"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a147074c64c2bf0883077a28432816947">printresults</a> ()</td></tr>
<tr class="separator:a147074c64c2bf0883077a28432816947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4f177690775ecc72820c67a88e66f7"><td class="memItemLeft" align="right" valign="top"><a id="aca4f177690775ecc72820c67a88e66f7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reassignSuspendedTask</b> (MWList&lt; <a class="el" href="classMWTask.html">MWTask</a> &gt; *running, MWWorkerID *w)</td></tr>
<tr class="separator:aca4f177690775ecc72820c67a88e66f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667ad4ad0017cd362835e7a89b43f061"><td class="memItemLeft" align="right" valign="top"><a id="a667ad4ad0017cd362835e7a89b43f061"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reassignIdleTask</b> (MWList&lt; MWWorkerID &gt; *workers, MWWorkerID *w)</td></tr>
<tr class="separator:a667ad4ad0017cd362835e7a89b43f061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7209348f0f9682935e191af9eb834b7"><td class="memItemLeft" align="right" valign="top"><a id="aa7209348f0f9682935e191af9eb834b7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>matchTask</b> (void *arg1, void *arg2)</td></tr>
<tr class="separator:aa7209348f0f9682935e191af9eb834b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a927f51c31e6f31998965770b06c31"><td class="memItemLeft" align="right" valign="top"><a id="ae1a927f51c31e6f31998965770b06c31"></a>
MWWorkerID *&#160;</td><td class="memItemRight" valign="bottom"><b>numberworker</b> (void *arg1, void *arg2)</td></tr>
<tr class="separator:ae1a927f51c31e6f31998965770b06c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9ed3676db0cc2ac5f5941beb15f1da"><td class="memItemLeft" align="right" valign="top"><a id="afc9ed3676db0cc2ac5f5941beb15f1da"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>prepare_update</b> (int mode)</td></tr>
<tr class="separator:afc9ed3676db0cc2ac5f5941beb15f1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac25d9fc7e9505bc14490d317c7560d"><td class="memItemLeft" align="right" valign="top"><a id="a8ac25d9fc7e9505bc14490d317c7560d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>pack_update</b> ()</td></tr>
<tr class="separator:a8ac25d9fc7e9505bc14490d317c7560d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a101f4b453675e7408ad9f3869a9804"><td class="memItemLeft" align="right" valign="top"><a id="a3a101f4b453675e7408ad9f3869a9804"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>send_update_message</b> ()</td></tr>
<tr class="separator:a3a101f4b453675e7408ad9f3869a9804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13919ea92ecde1abc954db7ad0935d2"><td class="memItemLeft" align="right" valign="top"><a id="ae13919ea92ecde1abc954db7ad0935d2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>send_update_message_to</b> (int worker)</td></tr>
<tr class="separator:ae13919ea92ecde1abc954db7ad0935d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">C. Worker Policy Management</div></td></tr>
<tr class="memitem:a97b4b046a3793d45e28bd1b2fddbd8c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a97b4b046a3793d45e28bd1b2fddbd8c1">set_suspension_policy</a> (MWSuspensionPolicy)</td></tr>
<tr class="separator:a97b4b046a3793d45e28bd1b2fddbd8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390d85849e7f510369c3b81ec4312de7"><td class="memItemLeft" align="right" valign="top"><a id="a390d85849e7f510369c3b81ec4312de7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a390d85849e7f510369c3b81ec4312de7">set_machine_ordering_policy</a> (MWMachineOrderingPolicy)</td></tr>
<tr class="memdesc:a390d85849e7f510369c3b81ec4312de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the machine ordering policy. <br /></td></tr>
<tr class="separator:a390d85849e7f510369c3b81ec4312de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">D. Event Handling Methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>In the case that the user wants to take specific actions when notified of processors going away, these methods may be reimplemented. Care must be taken when reimplementing these, or else things may get messed up.</p>
<p>Probably a better solution in the long run is to provide users hooks into these functions or something.</p>
<p>Basic default functionality that updates the known status of our virtual machine is provided. </p>
</div></td></tr>
<tr class="memitem:a73290f6fab539708112ec28a9e49b563"><td class="memItemLeft" align="right" valign="top">virtual MWReturn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a73290f6fab539708112ec28a9e49b563">handle_benchmark</a> (MWWorkerID *w)</td></tr>
<tr class="separator:a73290f6fab539708112ec28a9e49b563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c437b207bd8d327ceb84c5ce0c4304"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#af6c437b207bd8d327ceb84c5ce0c4304">handle_hostdel</a> ()</td></tr>
<tr class="separator:af6c437b207bd8d327ceb84c5ce0c4304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c21e0a4aba8ce4e03ebf7c3064f6b5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a91c21e0a4aba8ce4e03ebf7c3064f6b5">handle_hostsuspend</a> ()</td></tr>
<tr class="separator:a91c21e0a4aba8ce4e03ebf7c3064f6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1ef56017457e099e5947e81dd5d761"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a0e1ef56017457e099e5947e81dd5d761">handle_hostresume</a> ()</td></tr>
<tr class="separator:a0e1ef56017457e099e5947e81dd5d761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ee1fc1cbc9f5e07e3083f499d29be0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#ab4ee1fc1cbc9f5e07e3083f499d29be0">handle_taskexit</a> ()</td></tr>
<tr class="separator:ab4ee1fc1cbc9f5e07e3083f499d29be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1d0f044688941bd9a0e502b48c4676"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a7b1d0f044688941bd9a0e502b48c4676">handle_checksum</a> ()</td></tr>
<tr class="separator:a7b1d0f044688941bd9a0e502b48c4676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Benchmarking</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>We now have a user-defined benchmarking phase. The user can "register" a task that is sent to each worker upon startup. This way, the user knows which machines are fastest, and MW can perform can automatic "normalization" of the equivalent CPU time. </p>
</div></td></tr>
<tr class="memitem:ad0a6b24ff90e2d2ae1495062fb480f24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#ad0a6b24ff90e2d2ae1495062fb480f24">register_benchmark_task</a> (<a class="el" href="classMWTask.html">MWTask</a> *t)</td></tr>
<tr class="separator:ad0a6b24ff90e2d2ae1495062fb480f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e388c0446e7c42a8c6d0ee544a29b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMWTask.html">MWTask</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a77e388c0446e7c42a8c6d0ee544a29b6">get_benchmark_task</a> ()</td></tr>
<tr class="separator:a77e388c0446e7c42a8c6d0ee544a29b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a3063439d04c8048868d6c4d5c51c6778"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classMWRMComm.html">MWRMComm</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a3063439d04c8048868d6c4d5c51c6778">RMC</a></td></tr>
<tr class="separator:a3063439d04c8048868d6c4d5c51c6778"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">A. Pure Virtual Methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These are the methods from the <a class="el" href="classMWDriver.html">MWDriver</a> class that a user { must} reimplement in order to have to create an application. </p>
</div></td></tr>
<tr class="memitem:acf0edc86b06b46968114c8bb770791b2"><td class="memItemLeft" align="right" valign="top">virtual MWReturn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#acf0edc86b06b46968114c8bb770791b2">get_userinfo</a> (int argc, char *argv[])=0</td></tr>
<tr class="separator:acf0edc86b06b46968114c8bb770791b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618bdbf6e481a903455e068ba37ba0fa"><td class="memItemLeft" align="right" valign="top">virtual MWReturn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a618bdbf6e481a903455e068ba37ba0fa">setup_initial_tasks</a> (int *n, <a class="el" href="classMWTask.html">MWTask</a> ***task)=0</td></tr>
<tr class="separator:a618bdbf6e481a903455e068ba37ba0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920118e3f49ab81db5047d9ecdbcea2b"><td class="memItemLeft" align="right" valign="top">virtual MWReturn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a920118e3f49ab81db5047d9ecdbcea2b">act_on_completed_task</a> (<a class="el" href="classMWTask.html">MWTask</a> *)=0</td></tr>
<tr class="separator:a920118e3f49ab81db5047d9ecdbcea2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8199945d5f7c89bde67962da6d0c7ffe"><td class="memItemLeft" align="right" valign="top">virtual MWReturn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a8199945d5f7c89bde67962da6d0c7ffe">act_on_starting_worker</a> (MWWorkerID *w)</td></tr>
<tr class="separator:a8199945d5f7c89bde67962da6d0c7ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a142fda8b58806b1769558afd17c85c"><td class="memItemLeft" align="right" valign="top">virtual MWReturn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a6a142fda8b58806b1769558afd17c85c">pack_worker_init_data</a> (void)=0</td></tr>
<tr class="separator:a6a142fda8b58806b1769558afd17c85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaddea2ee086b0683b5d80ecb0438df91"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#aaddea2ee086b0683b5d80ecb0438df91">unpack_worker_initinfo</a> (MWWorkerID *w)</td></tr>
<tr class="separator:aaddea2ee086b0683b5d80ecb0438df91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6856e6de5bd17575e809e8e24140844"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#af6856e6de5bd17575e809e8e24140844">pack_driver_task_data</a> (void)</td></tr>
<tr class="separator:af6856e6de5bd17575e809e8e24140844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Data streaming/subtasks</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These are the methods that must be implemented to enable data streaming/ subtasks.</p><ul>
<li><a class="el" href="classMWDriver.html#aeb92065d166911049bec838253554555">act_on_completed_subtask()</a></li>
<li>MWWorker::execute_subtask</li>
<li>MWWorker::set_num_subtask</li>
<li><a class="el" href="classMWTask.html#a1a1b24e608337f787966b5d91f04f7de" title="Pack the subresult portion of the task. ">MWTask::pack_subresults</a></li>
<li><a class="el" href="classMWTask.html#ae6fe9fd144486e79c19a1087da1fd7ab" title="Unpack the subresult portion of the task. ">MWTask::unpack_subresults</a></li>
</ul>
<p>A subtask is identified by a <a class="el" href="classMWTask.html">MWTask</a> and a subtask id. The subtask id starts at 0 and ends at n-1 subtasks.</p>
<p>When subtasks are enabled, the Master sends the task to the Worker as usual. But instead of calling execute_task once, execute_subtask is called once per subtask id (starting at 0). At the end of each call, the result will be returned to the Master. After all subtasks have completed, the Master is notified that the Task has completed. </p>
</div></td></tr>
<tr class="memitem:aeb92065d166911049bec838253554555"><td class="memItemLeft" align="right" valign="top">virtual MWReturn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#aeb92065d166911049bec838253554555">act_on_completed_subtask</a> (<a class="el" href="classMWTask.html">MWTask</a> *)</td></tr>
<tr class="separator:aeb92065d166911049bec838253554555"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a7f5e4f492b6cae4d6ac5f83e48b79300"><td class="memItemLeft" align="right" valign="top"><a id="a7f5e4f492b6cae4d6ac5f83e48b79300"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>MWTask</b></td></tr>
<tr class="separator:a7f5e4f492b6cae4d6ac5f83e48b79300"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
B. Task List Management</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp38670e45ec2f524a92bf9b971b068861"></a>These functions are to manage the list of Tasks. MW provides default useful functionality for managing the list of tasks. </p>
</td></tr>
<tr class="memitem:abe90c9016afecc9bf9b68d4b9f3ba3b7"><td class="memItemLeft" align="right" valign="top"><a id="abe90c9016afecc9bf9b68d4b9f3ba3b7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#abe90c9016afecc9bf9b68d4b9f3ba3b7">set_task_key_function</a> (MWKey(*)(<a class="el" href="classMWTask.html">MWTask</a> *))</td></tr>
<tr class="memdesc:abe90c9016afecc9bf9b68d4b9f3ba3b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the function that <a class="el" href="classMWDriver.html">MWDriver</a> users to get the "key" for a task. <br /></td></tr>
<tr class="separator:abe90c9016afecc9bf9b68d4b9f3ba3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31fcd35f6e798994a2419db39f9f743"><td class="memItemLeft" align="right" valign="top"><a id="ae31fcd35f6e798994a2419db39f9f743"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#ae31fcd35f6e798994a2419db39f9f743">set_task_add_mode</a> (MWTaskAdditionMode)</td></tr>
<tr class="memdesc:ae31fcd35f6e798994a2419db39f9f743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the mode you wish for task addition. <br /></td></tr>
<tr class="separator:ae31fcd35f6e798994a2419db39f9f743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d413e43dbd55fdc211f0aebdd51ac47"><td class="memItemLeft" align="right" valign="top"><a id="a5d413e43dbd55fdc211f0aebdd51ac47"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a5d413e43dbd55fdc211f0aebdd51ac47">set_task_retrieve_mode</a> (MWTaskRetrievalMode)</td></tr>
<tr class="memdesc:a5d413e43dbd55fdc211f0aebdd51ac47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the mode you wish for task retrieval. <br /></td></tr>
<tr class="separator:a5d413e43dbd55fdc211f0aebdd51ac47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e6f72bc04a6c68046a41bc4292bf64"><td class="memItemLeft" align="right" valign="top"><a id="a69e6f72bc04a6c68046a41bc4292bf64"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a69e6f72bc04a6c68046a41bc4292bf64">sort_task_list</a> (void)</td></tr>
<tr class="memdesc:a69e6f72bc04a6c68046a41bc4292bf64"><td class="mdescLeft">&#160;</td><td class="mdescRight">This sorts the task list by the key that is set. <br /></td></tr>
<tr class="separator:a69e6f72bc04a6c68046a41bc4292bf64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c5921926e8780642d1b7dacf1a7016"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#ae4c5921926e8780642d1b7dacf1a7016">delete_tasks_worse_than</a> (MWKey)</td></tr>
<tr class="separator:ae4c5921926e8780642d1b7dacf1a7016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e7f38f78eba72bd69103a25730f9a9"><td class="memItemLeft" align="right" valign="top"><a id="a91e7f38f78eba72bd69103a25730f9a9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a91e7f38f78eba72bd69103a25730f9a9">get_number_tasks</a> ()</td></tr>
<tr class="memdesc:a91e7f38f78eba72bd69103a25730f9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of tasks on the todo list. <br /></td></tr>
<tr class="separator:a91e7f38f78eba72bd69103a25730f9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e42db5bff6f63d6a0dc4886a293a2e"><td class="memItemLeft" align="right" valign="top"><a id="a54e42db5bff6f63d6a0dc4886a293a2e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumWorkers</b> ()</td></tr>
<tr class="separator:a54e42db5bff6f63d6a0dc4886a293a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ca10beb1bce49579a44a657ed1f7a8"><td class="memItemLeft" align="right" valign="top"><a id="a71ca10beb1bce49579a44a657ed1f7a8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a71ca10beb1bce49579a44a657ed1f7a8">get_number_running_tasks</a> ()</td></tr>
<tr class="memdesc:a71ca10beb1bce49579a44a657ed1f7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of running tasks. <br /></td></tr>
<tr class="separator:a71ca10beb1bce49579a44a657ed1f7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2aea2804ff2f999ea206a3ee0f096a"><td class="memItemLeft" align="right" valign="top"><a id="a8d2aea2804ff2f999ea206a3ee0f096a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a8d2aea2804ff2f999ea206a3ee0f096a">print_task_keys</a> (void)</td></tr>
<tr class="memdesc:a8d2aea2804ff2f999ea206a3ee0f096a"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Mostly for debugging) &ndash; Prints the task keys in the todo list <br /></td></tr>
<tr class="separator:a8d2aea2804ff2f999ea206a3ee0f096a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49177e47b2d394aff1bc952e98bb7e19"><td class="memItemLeft" align="right" valign="top"><a id="a49177e47b2d394aff1bc952e98bb7e19"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a49177e47b2d394aff1bc952e98bb7e19">workClasses_set</a> (int num)</td></tr>
<tr class="memdesc:a49177e47b2d394aff1bc952e98bb7e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set number of workclasses. <br /></td></tr>
<tr class="separator:a49177e47b2d394aff1bc952e98bb7e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af239d1566ec6f0657891a027399d1217"><td class="memItemLeft" align="right" valign="top"><a id="af239d1566ec6f0657891a027399d1217"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#af239d1566ec6f0657891a027399d1217">workClasses_get</a> ()</td></tr>
<tr class="memdesc:af239d1566ec6f0657891a027399d1217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of workclasses. <br /></td></tr>
<tr class="separator:af239d1566ec6f0657891a027399d1217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ee843c55a50415b8c96c552267bd48"><td class="memItemLeft" align="right" valign="top"><a id="a62ee843c55a50415b8c96c552267bd48"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a62ee843c55a50415b8c96c552267bd48">stop_work</a> ()</td></tr>
<tr class="memdesc:a62ee843c55a50415b8c96c552267bd48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the worker working on this task container and send it a new task container. This should only be called in <a class="el" href="classMWDriver.html#a920118e3f49ab81db5047d9ecdbcea2b">act_on_completed_task(MWTask*)</a> <br /></td></tr>
<tr class="separator:a62ee843c55a50415b8c96c552267bd48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d60231d425b490ebca37dae8ffd47a"><td class="memItemLeft" align="right" valign="top"><a id="a31d60231d425b490ebca37dae8ffd47a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a31d60231d425b490ebca37dae8ffd47a">workClasses_getworkers</a> (int num)</td></tr>
<tr class="memdesc:a31d60231d425b490ebca37dae8ffd47a"><td class="mdescLeft">&#160;</td><td class="mdescRight">get number of workers in the specified work class <br /></td></tr>
<tr class="separator:a31d60231d425b490ebca37dae8ffd47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cbd67b86b21fa4676884107bdd48fce"><td class="memItemLeft" align="right" valign="top"><a id="a0cbd67b86b21fa4676884107bdd48fce"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a0cbd67b86b21fa4676884107bdd48fce">workClasses_gettasks</a> (int num)</td></tr>
<tr class="memdesc:a0cbd67b86b21fa4676884107bdd48fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">get number of tasks in the specified work class <br /></td></tr>
<tr class="separator:a0cbd67b86b21fa4676884107bdd48fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc5f80c5069e9bddcfee2ad9e5e32e4"><td class="memItemLeft" align="right" valign="top"><a id="a9dc5f80c5069e9bddcfee2ad9e5e32e4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a9dc5f80c5069e9bddcfee2ad9e5e32e4">refreshWorkers</a> (int i, MWREFRESH_TYPE)</td></tr>
<tr class="memdesc:a9dc5f80c5069e9bddcfee2ad9e5e32e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack new init data for all workers in group i. <br /></td></tr>
<tr class="separator:a9dc5f80c5069e9bddcfee2ad9e5e32e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa044c3810502c18efcb32dc77a66a138"><td class="memItemLeft" align="right" valign="top"><a id="aa044c3810502c18efcb32dc77a66a138"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#aa044c3810502c18efcb32dc77a66a138">addTask</a> (<a class="el" href="classMWTask.html">MWTask</a> *)</td></tr>
<tr class="memdesc:aa044c3810502c18efcb32dc77a66a138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a task to the list. <br /></td></tr>
<tr class="separator:aa044c3810502c18efcb32dc77a66a138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8a9ff2699780ce52ae600b658c9e4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a8b8a9ff2699780ce52ae600b658c9e4f">addTasks</a> (int, <a class="el" href="classMWTask.html">MWTask</a> **)</td></tr>
<tr class="separator:a8b8a9ff2699780ce52ae600b658c9e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dfb4201b9bce44ba2a59019f7fc2dd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a0dfb4201b9bce44ba2a59019f7fc2dd2">addSortedTasks</a> (int n, <a class="el" href="classMWTask.html">MWTask</a> **add_tasks)</td></tr>
<tr class="separator:a0dfb4201b9bce44ba2a59019f7fc2dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
. task timeout policy.</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp7940828ce8508c8dd1b9ee869fcde339"></a>MW provides a mechanism for performing tasks on workers that are potentially "lost". If the RMComm fails to notify MW of a worker going away in a timely fashion, the state of the computing platform and MW's vision of its state may become out of synch. In order to make sure that all tasks are done in a timely fashion, the user may set a time limit after which a task running on a "lost" worker may be rescheduled. </p>
</td></tr>
<tr class="memitem:ad41f96ba14ccc7712be09c0374eae9c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#ad41f96ba14ccc7712be09c0374eae9c9">set_worker_timeout_limit</a> (double timeout_limit, int timeout_frequency)</td></tr>
<tr class="separator:ad41f96ba14ccc7712be09c0374eae9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
E. Checkpoint Handling Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp591991dcf907ef1843a851b7742dde4d"></a>These are logical checkpoint handling functions. They are virtual, and are <em>entirely</em> application-specific. In them, the user must save the "state" of the application to permanent storage (disk). To do this, you need to:</p>
<p>{itemize}  Implement the methods <a class="el" href="classMWDriver.html#ab3a42409894c40f6992f01b433174588">write_master_state()</a> and <a class="el" href="classMWDriver.html#ab575d8dec66c8edadc165ebc6ea4e5a9">read_master_state()</a> in your derived <a class="el" href="classMWDriver.html">MWDriver</a> app.  Implement the methods write_ckpt_info() and read_ckpt_info() in your derived <a class="el" href="classMWTask.html">MWTask</a> class. {itemize}</p>
<p>Then <a class="el" href="classMWDriver.html">MWDriver</a> does the rest for you. When <a class="el" href="classMWDriver.html#ad41bdc32bc2f56f7816810bc4d260db2">checkpoint()</a> is called (see below) it opens up a known filename for writing. It passes the file pointer of that file to <a class="el" href="classMWDriver.html#ab3a42409894c40f6992f01b433174588">write_master_state()</a>, which dumps the "state" of the master to that fp. Here "sate" includes all the variables, info, etc of YOUR CLASS THAT WAS DERIVED FROM MWDRIVER. All state in MWDriver.C is taken care of (there's not much). Next, checkpoint will walk down the running queue and the todo queue and call each member's write_ckpt_info().</p>
<p>Upon restart, <a class="el" href="classMWDriver.html">MWDriver</a> will detect the presence of the checkpoint file and restart from it. It calls <a class="el" href="classMWDriver.html#ab575d8dec66c8edadc165ebc6ea4e5a9">read_master_state()</a>, which is the inverse of <a class="el" href="classMWDriver.html#ab3a42409894c40f6992f01b433174588">write_master_state()</a>. Then, for each task in the checkpoint file, it creates a new <a class="el" href="classMWTask.html">MWTask</a>, calls read_ckpt_info() on it, and adds it to the todo queue.</p>
<p>We start from there and proceed as normal.</p>
<p>One can set the "frequency" that checkpoint files will be written (using <a class="el" href="classMWDriver.html#aa34fc54dfba3806db87c297c8b39244a">set_checkpoint_frequency()</a>). The default frequency is zero - no checkpointing. When the frequency is set to n, every nth time that act_on_completed_task gets called, we checkpoint immediately afterwards. If your application involves "work steps", you probably will want to leave the frequency at zero and call checkpoint yourself at the end of a work step. </p>
</td></tr>
<tr class="memitem:a033da9ddab14c10d0c174ee778234221"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a033da9ddab14c10d0c174ee778234221">MIN_IN_MEM</a></td></tr>
<tr class="separator:a033da9ddab14c10d0c174ee778234221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7f11eb5034f28a30e51889e0a005b9"><td class="memItemLeft" align="right" valign="top"><a id="a8b7f11eb5034f28a30e51889e0a005b9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>NUM_IN_MEM_LO</b></td></tr>
<tr class="separator:a8b7f11eb5034f28a30e51889e0a005b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a1e82a5a6cb3cd9a7d3103f0d2f00e"><td class="memItemLeft" align="right" valign="top"><a id="aa3a1e82a5a6cb3cd9a7d3103f0d2f00e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>NUM_IN_MEM_HI</b></td></tr>
<tr class="separator:aa3a1e82a5a6cb3cd9a7d3103f0d2f00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1534851c44c7bddddac325f7ab490e8"><td class="memItemLeft" align="right" valign="top"><a id="af1534851c44c7bddddac325f7ab490e8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_IN_MEM</b></td></tr>
<tr class="separator:af1534851c44c7bddddac325f7ab490e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41bdc32bc2f56f7816810bc4d260db2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#ad41bdc32bc2f56f7816810bc4d260db2">checkpoint</a> ()</td></tr>
<tr class="separator:ad41bdc32bc2f56f7816810bc4d260db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a5b937b85d5a6cb90961249006942c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#af6a5b937b85d5a6cb90961249006942c">restart_from_ckpt</a> ()</td></tr>
<tr class="separator:af6a5b937b85d5a6cb90961249006942c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34fc54dfba3806db87c297c8b39244a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#aa34fc54dfba3806db87c297c8b39244a">set_checkpoint_frequency</a> (int freq)</td></tr>
<tr class="separator:aa34fc54dfba3806db87c297c8b39244a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f803ede53bb0d797bce81d56a33cdf9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a7f803ede53bb0d797bce81d56a33cdf9">set_checkpoint_time</a> (int secs)</td></tr>
<tr class="separator:a7f803ede53bb0d797bce81d56a33cdf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a42409894c40f6992f01b433174588"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#ab3a42409894c40f6992f01b433174588">write_master_state</a> (FILE *fp)</td></tr>
<tr class="separator:ab3a42409894c40f6992f01b433174588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab575d8dec66c8edadc165ebc6ea4e5a9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#ab575d8dec66c8edadc165ebc6ea4e5a9">read_master_state</a> (FILE *fp)</td></tr>
<tr class="separator:ab575d8dec66c8edadc165ebc6ea4e5a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa05516157b292a420ba6770fd2f493c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#afa05516157b292a420ba6770fd2f493c">swap_out_todo_tasks</a> (int num_in_mem=2048, int max_in_mem=204800, double max_key=DBL_MAX)</td></tr>
<tr class="separator:afa05516157b292a420ba6770fd2f493c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa70ab2dd6087ef2415824f770747f8f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#aaa70ab2dd6087ef2415824f770747f8f">swap_in_todo_tasks</a> (int min_in_mem=256, int num_in_mem=25600)</td></tr>
<tr class="separator:aaa70ab2dd6087ef2415824f770747f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184d950e15be4aa0ecb22d7eaea622fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a184d950e15be4aa0ecb22d7eaea622fe">is_TODO_empty</a> ()</td></tr>
<tr class="separator:a184d950e15be4aa0ecb22d7eaea622fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394381ef1a29bd1300184793e0e8c5da"><td class="memItemLeft" align="right" valign="top"><a id="a394381ef1a29bd1300184793e0e8c5da"></a>
<a class="el" href="classMWTask.html">MWTask</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>read_mem_task</b> (MWList&lt; <a class="el" href="classMWTask.html">MWTask</a> &gt; *tasks)</td></tr>
<tr class="separator:a394381ef1a29bd1300184793e0e8c5da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade316a0388ef55bf25048ed484b66a05"><td class="memItemLeft" align="right" valign="top"><a id="ade316a0388ef55bf25048ed484b66a05"></a>
<a class="el" href="classMWTask.html">MWTask</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>read_file_task</b> (FILE *f)</td></tr>
<tr class="separator:ade316a0388ef55bf25048ed484b66a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9791a018c5711fd6590af5f29d49877f"><td class="memItemLeft" align="right" valign="top"><a id="a9791a018c5711fd6590af5f29d49877f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>write_task</b> (FILE *f, <a class="el" href="classMWTask.html">MWTask</a> *t)</td></tr>
<tr class="separator:a9791a018c5711fd6590af5f29d49877f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d37eab370800bcc1fed37bff6c92643"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMWTask.html">MWTask</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a7d37eab370800bcc1fed37bff6c92643">gimme_a_task</a> ()=0</td></tr>
<tr class="separator:a7d37eab370800bcc1fed37bff6c92643"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Internal Task List Routines</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp9019d3d58b7b19d8d54671bc7d140680"></a>These methods and data are responsible for managing the list of tasks to be done </p>
</td></tr>
<tr class="memitem:a1d359e2a84216713f63d93ff343c68b2"><td class="memItemLeft" align="right" valign="top">MWKey(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a1d359e2a84216713f63d93ff343c68b2">task_key</a> )(<a class="el" href="classMWTask.html">MWTask</a> *)</td></tr>
<tr class="separator:a1d359e2a84216713f63d93ff343c68b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded3f8d1e5aa80a2492387533195d0aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMWTask.html">MWTask</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#aded3f8d1e5aa80a2492387533195d0aa">get_todo_head</a> ()</td></tr>
<tr class="separator:aded3f8d1e5aa80a2492387533195d0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de7c64341a08fd5badd62451c0c24dd"><td class="memItemLeft" align="right" valign="top"><a id="a5de7c64341a08fd5badd62451c0c24dd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>give_work</b> (MWWorkerID *w, <a class="el" href="classMWTask.html">MWTask</a> *t)</td></tr>
<tr class="separator:a5de7c64341a08fd5badd62451c0c24dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Worker management methods</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp80808ba8658e68b726aab8345b141562"></a>These methods act on the list of workers (or specifically) ID's of workers, that the driver knows about. </p>
</td></tr>
<tr class="memitem:a7cd3d2d9ba6a9e0e89511b6114a18632"><td class="memItemLeft" align="right" valign="top"><a id="a7cd3d2d9ba6a9e0e89511b6114a18632"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a7cd3d2d9ba6a9e0e89511b6114a18632">printWorkers</a> ()</td></tr>
<tr class="memdesc:a7cd3d2d9ba6a9e0e89511b6114a18632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the available workers. <br /></td></tr>
<tr class="separator:a7cd3d2d9ba6a9e0e89511b6114a18632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d81fbcaa68a8fb4ec11afcd81abc1b"><td class="memItemLeft" align="right" valign="top">MWWorkerID *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a08d81fbcaa68a8fb4ec11afcd81abc1b">get_workers_head</a> ()</td></tr>
<tr class="separator:a08d81fbcaa68a8fb4ec11afcd81abc1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada183d37afd5f06bf96c3f716ca90075"><td class="memItemLeft" align="right" valign="top"><a id="ada183d37afd5f06bf96c3f716ca90075"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#ada183d37afd5f06bf96c3f716ca90075">numWorkers</a> ()</td></tr>
<tr class="memdesc:ada183d37afd5f06bf96c3f716ca90075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the existing workers. <br /></td></tr>
<tr class="separator:ada183d37afd5f06bf96c3f716ca90075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4930b0cd40ef0940732ba0b5057c7f15"><td class="memItemLeft" align="right" valign="top"><a id="a4930b0cd40ef0940732ba0b5057c7f15"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a4930b0cd40ef0940732ba0b5057c7f15">numWorkers</a> (int arch)</td></tr>
<tr class="memdesc:a4930b0cd40ef0940732ba0b5057c7f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of workers in the given arch class. <br /></td></tr>
<tr class="separator:a4930b0cd40ef0940732ba0b5057c7f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0cd5e8c9a5e7561886fb1b7a48a7d1"><td class="memItemLeft" align="right" valign="top"><a id="a1b0cd5e8c9a5e7561886fb1b7a48a7d1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a1b0cd5e8c9a5e7561886fb1b7a48a7d1">numWorkersInState</a> (int ThisState)</td></tr>
<tr class="memdesc:a1b0cd5e8c9a5e7561886fb1b7a48a7d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of workers in the given state. <br /></td></tr>
<tr class="separator:a1b0cd5e8c9a5e7561886fb1b7a48a7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3bc92ab03d051502e69ca03de4928f"><td class="memItemLeft" align="right" valign="top"><a id="add3bc92ab03d051502e69ca03de4928f"></a>
MWKey&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#add3bc92ab03d051502e69ca03de4928f">return_best_todo_keyval</a> (void)</td></tr>
<tr class="memdesc:add3bc92ab03d051502e69ca03de4928f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value (only) of the best key in the Todo list. <br /></td></tr>
<tr class="separator:add3bc92ab03d051502e69ca03de4928f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0579cc034d3c83ea68ab456d222b8b79"><td class="memItemLeft" align="right" valign="top"><a id="a0579cc034d3c83ea68ab456d222b8b79"></a>
MWKey&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMWDriver.html#a0579cc034d3c83ea68ab456d222b8b79">return_best_running_keyval</a> (void)</td></tr>
<tr class="memdesc:a0579cc034d3c83ea68ab456d222b8b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the best value (only) of the best key in the Running list. <br /></td></tr>
<tr class="separator:a0579cc034d3c83ea68ab456d222b8b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class is responsible for managing an application in an opportunistic environment. The goal is to be completely fault - tolerant, dealing with all possiblities of host (worker) problems. To do this, the <a class="el" href="classMWDriver.html">MWDriver</a> class manages a set of tasks and a set of workers. It monitors messages about hosts coming up and going down, and assigns tasks appropriately. </p><pre class="fragment">This class is built upon some sort of resource management and 
message passing lower layer.  Previously, it was built directly 
on top of Condor - PVM, but the interface to that has been 
abstracted away so that it can use any facility that provides 
for resource management and message passing.  See the abstract
MWRMComm class for details of this lower layer.  When interfacing
with this level, you'll have use the RMC object that's a static
member of the MWDriver, MWTask, and MWWorker class.  
</pre><p>To implement an application, a user must derive a class from this base class and implement the following methods:</p>
<ul>
<li><a class="el" href="classMWDriver.html#acf0edc86b06b46968114c8bb770791b2">get_userinfo()</a></li>
<li><a class="el" href="classMWDriver.html#a618bdbf6e481a903455e068ba37ba0fa">setup_initial_tasks()</a></li>
<li><a class="el" href="classMWDriver.html#a6a142fda8b58806b1769558afd17c85c">pack_worker_init_data()</a></li>
<li><a class="el" href="classMWDriver.html#a920118e3f49ab81db5047d9ecdbcea2b">act_on_completed_task()</a></li>
</ul>
<pre class="fragment">For a higher level of control regarding distribution of tasks to workers, 
tasks and workers may be enrolled to workclasses/groups by calling the
following methods:

- MWWorkerID::addGroup()
- MWWorkerID::deleteGroup()
- MWTask::addGroup()
- MWTask::deleteGroup()

These methods can be called by an application using workclasses:

- workClasses_set()  (Required)
- workClasses_get()
- workClasses_gettasks()
- workClasses_getworkers()

To enroll workers in workclasses, there are two options:
- act_on_starting_worker() can be implemented to enroll workers to 
workclasses based on MWWorkerID info at the start of execution
- pack_worker_init_data() can be implemented to enroll workers. When used 
in conjunction with refreshWorkers(), can change workclass of workers in the        middle of execution.    
</pre><p>Similar application dependent methods must be implemented for the "Task" of work to be done and the "Worker" who performs the tasks.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classMWTask.html">MWTask</a> </dd>
<dd>
<a class="el" href="classMWWorker.html">MWWorker</a> </dd>
<dd>
<a class="el" href="classMWRMComm.html">MWRMComm</a> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Mike Yoder, Jeff Linderoth, Jean-Pierre Goux, Sanjeev Kulkarni </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a05b1dac7d50ff571c480ff386e6fcb30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05b1dac7d50ff571c480ff386e6fcb30">&#9670;&nbsp;</a></span>~MWDriver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MWDriver::~MWDriver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor - walks through lists of tasks &amp; workers and deletes them. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aeb92065d166911049bec838253554555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb92065d166911049bec838253554555">&#9670;&nbsp;</a></span>act_on_completed_subtask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual MWReturn MWDriver::act_on_completed_subtask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMWTask.html">MWTask</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function performs an action that happens once the Driver receives notification of a completed subtask. </p>

<p class="reference">References <a class="el" href="classMWDriver.html#a0dfb4201b9bce44ba2a59019f7fc2dd2">addSortedTasks()</a>, <a class="el" href="classMWDriver.html#aa044c3810502c18efcb32dc77a66a138">addTask()</a>, <a class="el" href="classMWDriver.html#a8b8a9ff2699780ce52ae600b658c9e4f">addTasks()</a>, <a class="el" href="classMWDriver.html#ad41bdc32bc2f56f7816810bc4d260db2">checkpoint()</a>, <a class="el" href="classMWDriver.html#ae4c5921926e8780642d1b7dacf1a7016">delete_tasks_worse_than()</a>, <a class="el" href="classMWDriver.html#a71ca10beb1bce49579a44a657ed1f7a8">get_number_running_tasks()</a>, <a class="el" href="classMWDriver.html#a91e7f38f78eba72bd69103a25730f9a9">get_number_tasks()</a>, <a class="el" href="classMWDriver.html#a73290f6fab539708112ec28a9e49b563">handle_benchmark()</a>, <a class="el" href="classMWDriver.html#a7b1d0f044688941bd9a0e502b48c4676">handle_checksum()</a>, <a class="el" href="classMWDriver.html#af6c437b207bd8d327ceb84c5ce0c4304">handle_hostdel()</a>, <a class="el" href="classMWDriver.html#a0e1ef56017457e099e5947e81dd5d761">handle_hostresume()</a>, <a class="el" href="classMWDriver.html#a91c21e0a4aba8ce4e03ebf7c3064f6b5">handle_hostsuspend()</a>, <a class="el" href="classMWDriver.html#ab4ee1fc1cbc9f5e07e3083f499d29be0">handle_taskexit()</a>, <a class="el" href="classMWDriver.html#a8d2aea2804ff2f999ea206a3ee0f096a">print_task_keys()</a>, <a class="el" href="classMWDriver.html#a9dc5f80c5069e9bddcfee2ad9e5e32e4">refreshWorkers()</a>, <a class="el" href="classMWDriver.html#af6a5b937b85d5a6cb90961249006942c">restart_from_ckpt()</a>, <a class="el" href="classMWDriver.html#aa34fc54dfba3806db87c297c8b39244a">set_checkpoint_frequency()</a>, <a class="el" href="classMWDriver.html#a7f803ede53bb0d797bce81d56a33cdf9">set_checkpoint_time()</a>, <a class="el" href="classMWDriver.html#a390d85849e7f510369c3b81ec4312de7">set_machine_ordering_policy()</a>, <a class="el" href="classMWDriver.html#a97b4b046a3793d45e28bd1b2fddbd8c1">set_suspension_policy()</a>, <a class="el" href="classMWDriver.html#ae31fcd35f6e798994a2419db39f9f743">set_task_add_mode()</a>, <a class="el" href="classMWDriver.html#abe90c9016afecc9bf9b68d4b9f3ba3b7">set_task_key_function()</a>, <a class="el" href="classMWDriver.html#a5d413e43dbd55fdc211f0aebdd51ac47">set_task_retrieve_mode()</a>, <a class="el" href="classMWDriver.html#ad41f96ba14ccc7712be09c0374eae9c9">set_worker_timeout_limit()</a>, <a class="el" href="classMWDriver.html#a69e6f72bc04a6c68046a41bc4292bf64">sort_task_list()</a>, <a class="el" href="classMWDriver.html#a62ee843c55a50415b8c96c552267bd48">stop_work()</a>, <a class="el" href="classMWDriver.html#af239d1566ec6f0657891a027399d1217">workClasses_get()</a>, <a class="el" href="classMWDriver.html#a0cbd67b86b21fa4676884107bdd48fce">workClasses_gettasks()</a>, <a class="el" href="classMWDriver.html#a31d60231d425b490ebca37dae8ffd47a">workClasses_getworkers()</a>, and <a class="el" href="classMWDriver.html#a49177e47b2d394aff1bc952e98bb7e19">workClasses_set()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMWDriver.html#a7e9140329e1c6a2b4b7f1a0a9a365cab">go()</a>.</p>

</div>
</div>
<a id="a920118e3f49ab81db5047d9ecdbcea2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a920118e3f49ab81db5047d9ecdbcea2b">&#9670;&nbsp;</a></span>act_on_completed_task()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual MWReturn MWDriver::act_on_completed_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMWTask.html">MWTask</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function performs actions that happen once the Driver receives notification of a completed task. You will need to cast the <a class="el" href="classMWTask.html">MWTask</a> * to a pointer of the Task type derived for your application. For example </p><pre class="fragment">            \begin{verbatim}
            My_Task *dt = dynamic_cast&lt;My_Task *&gt; ( t );
            assert( dt );     
            \end{verbatim}</pre> 
<p class="reference">Referenced by <a class="el" href="classMWDriver.html#a0e1ef56017457e099e5947e81dd5d761">handle_hostresume()</a>.</p>

</div>
</div>
<a id="a8199945d5f7c89bde67962da6d0c7ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8199945d5f7c89bde67962da6d0c7ffe">&#9670;&nbsp;</a></span>act_on_starting_worker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MWReturn MWDriver::act_on_starting_worker </td>
          <td>(</td>
          <td class="paramtype">MWWorkerID *&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is called once the Worker is done with the TaskContainer.</p><ul>
<li>Put the logic for this in <a class="el" href="classMWDriver.html">MWDriver</a> This function should be implemented by the application to assign the workClass number to the worker if it is doing intelligent work scheduling. </li>
</ul>

<p class="reference">Referenced by <a class="el" href="classMWDriver.html#ae4c5921926e8780642d1b7dacf1a7016">delete_tasks_worse_than()</a>.</p>

</div>
</div>
<a id="a0dfb4201b9bce44ba2a59019f7fc2dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dfb4201b9bce44ba2a59019f7fc2dd2">&#9670;&nbsp;</a></span>addSortedTasks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MWDriver::addSortedTasks </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMWTask.html">MWTask</a> **&#160;</td>
          <td class="paramname"><em>add_tasks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will add a list of tasks that are sorted by key. Efficiency can be greatly improved by using this function </p>

<p class="reference">References <a class="el" href="classMWTask.html#a97ee3d8338dd2e02a20631e2e595f237">MWTask::addGroup()</a>, <a class="el" href="classMWRMComm.html#ab4ce8dae654516f77d20fc912da3e188">MWRMComm::exit()</a>, <a class="el" href="classMWWorker.html#acd0f3f0d8637352325f1f00919dfeb6f">MWWorker::go()</a>, <a class="el" href="classMWRMComm.html#a8cc7e0fa6b024fe7441fca581b4edf83">MWRMComm::hostadd()</a>, <a class="el" href="classMWTask.html#ad133dd1be9c974871a1564e78eed8715">MWTask::number</a>, <a class="el" href="classMWDriver.html#a3063439d04c8048868d6c4d5c51c6778">RMC</a>, and <a class="el" href="classMWDriver.html#a1d359e2a84216713f63d93ff343c68b2">task_key</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMWDriver.html#aeb92065d166911049bec838253554555">act_on_completed_subtask()</a>.</p>

</div>
</div>
<a id="a8b8a9ff2699780ce52ae600b658c9e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b8a9ff2699780ce52ae600b658c9e4f">&#9670;&nbsp;</a></span>addTasks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MWDriver::addTasks </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMWTask.html">MWTask</a> **&#160;</td>
          <td class="paramname"><em>add_tasks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a bunch of tasks to the list. You do this by making an array of pointers to MWTasks and giving that array to this function. The <a class="el" href="classMWDriver.html">MWDriver</a> will take over memory management for the MWTasks, but not for the array of pointers, so don't forget to delete [] it! </p>

<p class="reference">References <a class="el" href="classMWTask.html#a97ee3d8338dd2e02a20631e2e595f237">MWTask::addGroup()</a>, <a class="el" href="classMWRMComm.html#ab4ce8dae654516f77d20fc912da3e188">MWRMComm::exit()</a>, <a class="el" href="classMWTask.html#ad133dd1be9c974871a1564e78eed8715">MWTask::number</a>, and <a class="el" href="classMWDriver.html#a3063439d04c8048868d6c4d5c51c6778">RMC</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMWDriver.html#aeb92065d166911049bec838253554555">act_on_completed_subtask()</a>, and <a class="el" href="classMWDriver.html#a7e9140329e1c6a2b4b7f1a0a9a365cab">go()</a>.</p>

</div>
</div>
<a id="ad41bdc32bc2f56f7816810bc4d260db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad41bdc32bc2f56f7816810bc4d260db2">&#9670;&nbsp;</a></span>checkpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MWDriver::checkpoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function writes the current state of the job to disk. See the section header to see how it does this. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classMWTask.html">MWTask</a> </dd></dl>

<p class="reference">References <a class="el" href="classMWDriver.html#a3063439d04c8048868d6c4d5c51c6778">RMC</a>, <a class="el" href="classMWTask.html#a3899784f624c803ae211ab781f180ca3">MWTask::taskType</a>, <a class="el" href="classMWRMComm.html#a497ab814d1bc00c8fa562e85c2fd6570">MWRMComm::write_checkpoint()</a>, <a class="el" href="classMWTask.html#af6ec7477171732f7e3a6de76a86b37a6">MWTask::write_ckpt_info()</a>, and <a class="el" href="classMWDriver.html#ab3a42409894c40f6992f01b433174588">write_master_state()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMWDriver.html#aeb92065d166911049bec838253554555">act_on_completed_subtask()</a>, <a class="el" href="classMWDriver.html#a0e1ef56017457e099e5947e81dd5d761">handle_hostresume()</a>, <a class="el" href="classMWDriver.html#af6a5b937b85d5a6cb90961249006942c">restart_from_ckpt()</a>, <a class="el" href="classMWDriver.html#aaa70ab2dd6087ef2415824f770747f8f">swap_in_todo_tasks()</a>, and <a class="el" href="classMWDriver.html#afa05516157b292a420ba6770fd2f493c">swap_out_todo_tasks()</a>.</p>

</div>
</div>
<a id="ae4c5921926e8780642d1b7dacf1a7016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c5921926e8780642d1b7dacf1a7016">&#9670;&nbsp;</a></span>delete_tasks_worse_than()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MWDriver::delete_tasks_worse_than </td>
          <td>(</td>
          <td class="paramtype">MWKey&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This deletes all tasks in the task list with a key worse than the one specified </p>

<p class="reference">References <a class="el" href="classMWDriver.html#a8199945d5f7c89bde67962da6d0c7ffe">act_on_starting_worker()</a>, <a class="el" href="classMWRMComm.html#ac74cbe518e434e9796eba40687a3ec6b">MWRMComm::get_num_exec_classes()</a>, <a class="el" href="classMWRMComm.html#a4ded74716925e2213d6f898543491ce1">MWRMComm::hostaddlogic()</a>, <a class="el" href="classMWTask.html#ad133dd1be9c974871a1564e78eed8715">MWTask::number</a>, <a class="el" href="classMWDriver.html#ada183d37afd5f06bf96c3f716ca90075">numWorkers()</a>, <a class="el" href="classMWTask.html#a013363bc92d9ce9f0fc36fb4171b03d1">MWTask::printself()</a>, <a class="el" href="classMWRMComm.html#a532c61bca2f954df18a46fb4f1578606">MWRMComm::removeWorker()</a>, <a class="el" href="classMWDriver.html#a3063439d04c8048868d6c4d5c51c6778">RMC</a>, and <a class="el" href="classMWDriver.html#a1d359e2a84216713f63d93ff343c68b2">task_key</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMWDriver.html#aeb92065d166911049bec838253554555">act_on_completed_subtask()</a>.</p>

</div>
</div>
<a id="a77e388c0446e7c42a8c6d0ee544a29b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e388c0446e7c42a8c6d0ee544a29b6">&#9670;&nbsp;</a></span>get_benchmark_task()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMWTask.html">MWTask</a>* MWDriver::get_benchmark_task </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>get the benchmark task </p>

<p class="reference">Referenced by <a class="el" href="classMWDriver.html#a7b1d0f044688941bd9a0e502b48c4676">handle_checksum()</a>, and <a class="el" href="classMWDriver.html#a9dc5f80c5069e9bddcfee2ad9e5e32e4">refreshWorkers()</a>.</p>

</div>
</div>
<a id="aded3f8d1e5aa80a2492387533195d0aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aded3f8d1e5aa80a2492387533195d0aa">&#9670;&nbsp;</a></span>get_todo_head()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMWTask.html">MWTask</a> * MWDriver::get_todo_head </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is Jeff's nasty addition so that he can get access to the tasks on the master </p>

</div>
</div>
<a id="acf0edc86b06b46968114c8bb770791b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf0edc86b06b46968114c8bb770791b2">&#9670;&nbsp;</a></span>get_userinfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual MWReturn MWDriver::get_userinfo </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is called to read in all information specific to a user's application and do any initialization on this information. </p>

<p class="reference">Referenced by <a class="el" href="classMWDriver.html#a7e9140329e1c6a2b4b7f1a0a9a365cab">go()</a>.</p>

</div>
</div>
<a id="a08d81fbcaa68a8fb4ec11afcd81abc1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08d81fbcaa68a8fb4ec11afcd81abc1b">&#9670;&nbsp;</a></span>get_workers_head()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MWWorkerID * MWDriver::get_workers_head </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Another terrible addition so that Jeff can print out the worker list in his own format </p>

<p class="reference">References <a class="el" href="classMWRMComm.html#ac74cbe518e434e9796eba40687a3ec6b">MWRMComm::get_num_exec_classes()</a>, <a class="el" href="classMWDriver.html#a71ca10beb1bce49579a44a657ed1f7a8">get_number_running_tasks()</a>, <a class="el" href="classMWDriver.html#a91e7f38f78eba72bd69103a25730f9a9">get_number_tasks()</a>, <a class="el" href="classMWRMComm.html#a12c2add8bea8577d5d150c49c7d42e5d">MWRMComm::initsend()</a>, <a class="el" href="classMWDriver.html#a1b0cd5e8c9a5e7561886fb1b7a48a7d1">numWorkersInState()</a>, <a class="el" href="classMWDriver.html#a3063439d04c8048868d6c4d5c51c6778">RMC</a>, <a class="el" href="classMWRMComm.html#abfe166a1b1c70e35069fbc0f1beb250f">MWRMComm::send()</a>, and <a class="el" href="classMWRMComm.html#a9723b0a13c493923e1282d7832b86b65">MWRMComm::set_target_num_workers()</a>.</p>

</div>
</div>
<a id="a7d37eab370800bcc1fed37bff6c92643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d37eab370800bcc1fed37bff6c92643">&#9670;&nbsp;</a></span>gimme_a_task()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMWTask.html">MWTask</a>* MWDriver::gimme_a_task </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>It's really annoying that the user has to do this, but they do. The thing is, we have to make a new task of the user's derived type when we read in the checkpoint file.</p>
<p>If your application coredumps when trying to restart from a checkpoint, it might be becasue you haven't implemented this function.</p>
<p>{verbatim} MWTask* <a class="el" href="classMWDriver.html#a7d37eab370800bcc1fed37bff6c92643">gimme_a_task()</a> { return new &lt;your derived="" task="" class&gt;=""&gt;; } {verbatim} </p>

<p class="reference">Referenced by <a class="el" href="classMWDriver.html#ab575d8dec66c8edadc165ebc6ea4e5a9">read_master_state()</a>, <a class="el" href="classMWDriver.html#af6a5b937b85d5a6cb90961249006942c">restart_from_ckpt()</a>, and <a class="el" href="classMWDriver.html#aaa70ab2dd6087ef2415824f770747f8f">swap_in_todo_tasks()</a>.</p>

</div>
</div>
<a id="a7e9140329e1c6a2b4b7f1a0a9a365cab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e9140329e1c6a2b4b7f1a0a9a365cab">&#9670;&nbsp;</a></span>go() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MWDriver::go </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method runs the entire fault-tolerant application in the condor environment. What is <em>really</em> does is call setup_master(), then master(), then <a class="el" href="classMWDriver.html#a147074c64c2bf0883077a28432816947">printresults()</a>, and then ends. See the other functions for details. </p>

<p class="reference">References <a class="el" href="classMWDriver.html#aeb92065d166911049bec838253554555">act_on_completed_subtask()</a>, <a class="el" href="classMWDriver.html#a8b8a9ff2699780ce52ae600b658c9e4f">addTasks()</a>, <a class="el" href="classMWRMComm.html#a7670401dc33950de354e41183dd392cd">MWRMComm::bufinfo()</a>, <a class="el" href="classMWRMComm.html#ab4ce8dae654516f77d20fc912da3e188">MWRMComm::exit()</a>, <a class="el" href="classMWDriver.html#acf0edc86b06b46968114c8bb770791b2">get_userinfo()</a>, <a class="el" href="classMWDriver.html#a73290f6fab539708112ec28a9e49b563">handle_benchmark()</a>, <a class="el" href="classMWDriver.html#a7b1d0f044688941bd9a0e502b48c4676">handle_checksum()</a>, <a class="el" href="classMWDriver.html#af6c437b207bd8d327ceb84c5ce0c4304">handle_hostdel()</a>, <a class="el" href="classMWDriver.html#a0e1ef56017457e099e5947e81dd5d761">handle_hostresume()</a>, <a class="el" href="classMWDriver.html#a91c21e0a4aba8ce4e03ebf7c3064f6b5">handle_hostsuspend()</a>, <a class="el" href="classMWDriver.html#ab4ee1fc1cbc9f5e07e3083f499d29be0">handle_taskexit()</a>, <a class="el" href="classMWRMComm.html#a50088a80976b2aee031e987393bceeb2">MWRMComm::init_beginning_workers()</a>, <a class="el" href="classMWRMComm.html#a12c2add8bea8577d5d150c49c7d42e5d">MWRMComm::initsend()</a>, <a class="el" href="classMWDriver.html#a184d950e15be4aa0ecb22d7eaea622fe">is_TODO_empty()</a>, <a class="el" href="classMWDriver.html#a147074c64c2bf0883077a28432816947">printresults()</a>, <a class="el" href="classMWDriver.html#a7cd3d2d9ba6a9e0e89511b6114a18632">printWorkers()</a>, <a class="el" href="classMWRMComm.html#a9f10630a68baee310e48d0df33fb2dd8">MWRMComm::recv()</a>, <a class="el" href="classMWRMComm.html#a831a7994d307d075f877b4415cb65657">MWRMComm::restart_beginning_workers()</a>, <a class="el" href="classMWDriver.html#af6a5b937b85d5a6cb90961249006942c">restart_from_ckpt()</a>, <a class="el" href="classMWDriver.html#a3063439d04c8048868d6c4d5c51c6778">RMC</a>, <a class="el" href="classMWRMComm.html#abfe166a1b1c70e35069fbc0f1beb250f">MWRMComm::send()</a>, <a class="el" href="classMWRMComm.html#a6c500b03f49fbab5a879dfec1f8c492e">MWRMComm::setup()</a>, <a class="el" href="classMWDriver.html#a618bdbf6e481a903455e068ba37ba0fa">setup_initial_tasks()</a>, <a class="el" href="classMWRMComm.html#a0064a409542e4308c77eb598b161138e">MWRMComm::start_worker()</a>, <a class="el" href="classMWRMComm.html#af5fe22ee99ecbb178dad85b6474fe61f">MWRMComm::unpack()</a>, and <a class="el" href="classMWDriver.html#a49177e47b2d394aff1bc952e98bb7e19">workClasses_set()</a>.</p>

</div>
</div>
<a id="a4d3d2d8a2fac34f02c0573fabb29f1cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d3d2d8a2fac34f02c0573fabb29f1cf">&#9670;&nbsp;</a></span>go() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MWDriver::go </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This version of go simply calls go(0, NULL). </p>

<p class="reference">References <a class="el" href="classMWDriver.html#a4d3d2d8a2fac34f02c0573fabb29f1cf">go()</a>, and <a class="el" href="classMWDriver.html#a147074c64c2bf0883077a28432816947">printresults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMWDriver.html#a4d3d2d8a2fac34f02c0573fabb29f1cf">go()</a>.</p>

</div>
</div>
<a id="a73290f6fab539708112ec28a9e49b563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73290f6fab539708112ec28a9e49b563">&#9670;&nbsp;</a></span>handle_benchmark()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MWReturn MWDriver::handle_benchmark </td>
          <td>(</td>
          <td class="paramtype">MWWorkerID *&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Here, we get back the benchmarking results, which tell us something about the worker we've got. Also, we could get some sort of error back from the worker at this stage, in which case we remove it. </p>

<p class="reference">References <a class="el" href="classMWRMComm.html#a12c2add8bea8577d5d150c49c7d42e5d">MWRMComm::initsend()</a>, <a class="el" href="classMWTask.html#ad133dd1be9c974871a1564e78eed8715">MWTask::number</a>, <a class="el" href="classMWRMComm.html#a611ac04479ee1c3731cf459427d18fb4">MWRMComm::pack()</a>, <a class="el" href="classMWDriver.html#af6856e6de5bd17575e809e8e24140844">pack_driver_task_data()</a>, <a class="el" href="classMWTask.html#a57073276fad38e58edda79d35021a52c">MWTask::pack_work()</a>, <a class="el" href="classMWRMComm.html#a532c61bca2f954df18a46fb4f1578606">MWRMComm::removeWorker()</a>, <a class="el" href="classMWDriver.html#a3063439d04c8048868d6c4d5c51c6778">RMC</a>, <a class="el" href="classMWRMComm.html#abfe166a1b1c70e35069fbc0f1beb250f">MWRMComm::send()</a>, <a class="el" href="classMWTask.html#a3899784f624c803ae211ab781f180ca3">MWTask::taskType</a>, <a class="el" href="classMWRMComm.html#af5fe22ee99ecbb178dad85b6474fe61f">MWRMComm::unpack()</a>, and <a class="el" href="classMWTask.html#ab7fc4bb108116fe6f5b33b818e6a8650">MWTask::worker</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMWDriver.html#aeb92065d166911049bec838253554555">act_on_completed_subtask()</a>, and <a class="el" href="classMWDriver.html#a7e9140329e1c6a2b4b7f1a0a9a365cab">go()</a>.</p>

</div>
</div>
<a id="a7b1d0f044688941bd9a0e502b48c4676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1d0f044688941bd9a0e502b48c4676">&#9670;&nbsp;</a></span>handle_checksum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MWDriver::handle_checksum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Routine to handle when the communication layer says that a checksum error happened. If the underlying Communitor gives a reliably reliable communication then this messge need not be generated. But for some Communicators like MW-File we may need some thing like this. </p>

<p class="reference">References <a class="el" href="classMWDriver.html#a77e388c0446e7c42a8c6d0ee544a29b6">get_benchmark_task()</a>, <a class="el" href="classMWRMComm.html#a12c2add8bea8577d5d150c49c7d42e5d">MWRMComm::initsend()</a>, <a class="el" href="classMWRMComm.html#a611ac04479ee1c3731cf459427d18fb4">MWRMComm::pack()</a>, <a class="el" href="classMWTask.html#a57073276fad38e58edda79d35021a52c">MWTask::pack_work()</a>, <a class="el" href="classMWDriver.html#a6a142fda8b58806b1769558afd17c85c">pack_worker_init_data()</a>, <a class="el" href="classMWRMComm.html#a532c61bca2f954df18a46fb4f1578606">MWRMComm::removeWorker()</a>, <a class="el" href="classMWDriver.html#a3063439d04c8048868d6c4d5c51c6778">RMC</a>, <a class="el" href="classMWRMComm.html#abfe166a1b1c70e35069fbc0f1beb250f">MWRMComm::send()</a>, and <a class="el" href="classMWRMComm.html#acb947438d2447b15a0d621392802ff2e">MWRMComm::who()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMWDriver.html#aeb92065d166911049bec838253554555">act_on_completed_subtask()</a>, and <a class="el" href="classMWDriver.html#a7e9140329e1c6a2b4b7f1a0a9a365cab">go()</a>.</p>

</div>
</div>
<a id="af6c437b207bd8d327ceb84c5ce0c4304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6c437b207bd8d327ceb84c5ce0c4304">&#9670;&nbsp;</a></span>handle_hostdel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MWDriver::handle_hostdel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is what gets called when a host goes away. We figure out who died, remove that worker from our records, remove its task from the running queue (if it was running one) and put that task back on the todo list. </p>

<p class="reference">References <a class="el" href="classMWDriver.html#a3063439d04c8048868d6c4d5c51c6778">RMC</a>, and <a class="el" href="classMWRMComm.html#acb947438d2447b15a0d621392802ff2e">MWRMComm::who()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMWDriver.html#aeb92065d166911049bec838253554555">act_on_completed_subtask()</a>, and <a class="el" href="classMWDriver.html#a7e9140329e1c6a2b4b7f1a0a9a365cab">go()</a>.</p>

</div>
</div>
<a id="a0e1ef56017457e099e5947e81dd5d761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e1ef56017457e099e5947e81dd5d761">&#9670;&nbsp;</a></span>handle_hostresume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MWDriver::handle_hostresume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Here's where you go when a host gets resumed. Usually, you do nothing...but it's nice to know... </p>

<p class="reference">References <a class="el" href="classMWDriver.html#a920118e3f49ab81db5047d9ecdbcea2b">act_on_completed_task()</a>, <a class="el" href="classMWDriver.html#ad41bdc32bc2f56f7816810bc4d260db2">checkpoint()</a>, <a class="el" href="classMWTask.html#a5f954bdae3d554327beab944c8e51125">MWTask::cpu_time</a>, <a class="el" href="classMWTask.html#a918669fb822fed85add7b5ca3b8aeafe">MWTask::deleteGroup()</a>, <a class="el" href="classMWTask.html#ad133dd1be9c974871a1564e78eed8715">MWTask::number</a>, <a class="el" href="classMWDriver.html#a3063439d04c8048868d6c4d5c51c6778">RMC</a>, <a class="el" href="classMWDriver.html#a1d359e2a84216713f63d93ff343c68b2">task_key</a>, <a class="el" href="classMWTask.html#a3899784f624c803ae211ab781f180ca3">MWTask::taskType</a>, <a class="el" href="classMWRMComm.html#af5fe22ee99ecbb178dad85b6474fe61f">MWRMComm::unpack()</a>, <a class="el" href="classMWTask.html#ab22e3eb9a27b8d115063e79067856166">MWTask::unpack_results()</a>, <a class="el" href="classMWRMComm.html#acb947438d2447b15a0d621392802ff2e">MWRMComm::who()</a>, <a class="el" href="classMWTask.html#ab7fc4bb108116fe6f5b33b818e6a8650">MWTask::worker</a>, and <a class="el" href="classMWTask.html#ae503d6480ef81dcc1ccd7927e4655226">MWTask::working_time</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMWDriver.html#aeb92065d166911049bec838253554555">act_on_completed_subtask()</a>, and <a class="el" href="classMWDriver.html#a7e9140329e1c6a2b4b7f1a0a9a365cab">go()</a>.</p>

</div>
</div>
<a id="a91c21e0a4aba8ce4e03ebf7c3064f6b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91c21e0a4aba8ce4e03ebf7c3064f6b5">&#9670;&nbsp;</a></span>handle_hostsuspend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MWDriver::handle_hostsuspend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implements a suspension policy. Currently either DEFAULT or REASSIGN, depending on how suspensionPolicy is set. </p>

<p class="reference">References <a class="el" href="classMWTask.html#ad133dd1be9c974871a1564e78eed8715">MWTask::number</a>, <a class="el" href="classMWDriver.html#a3063439d04c8048868d6c4d5c51c6778">RMC</a>, and <a class="el" href="classMWRMComm.html#acb947438d2447b15a0d621392802ff2e">MWRMComm::who()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMWDriver.html#aeb92065d166911049bec838253554555">act_on_completed_subtask()</a>, and <a class="el" href="classMWDriver.html#a7e9140329e1c6a2b4b7f1a0a9a365cab">go()</a>.</p>

</div>
</div>
<a id="ab4ee1fc1cbc9f5e07e3083f499d29be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4ee1fc1cbc9f5e07e3083f499d29be0">&#9670;&nbsp;</a></span>handle_taskexit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MWDriver::handle_taskexit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>We do basically the same thing as <a class="el" href="classMWDriver.html#af6c437b207bd8d327ceb84c5ce0c4304">handle_hostdel()</a>. One might {<em>think}</em> that we could restart something on that host; in practice, however &ndash; especially with the Condor-PVM RMComm implementation &ndash; it means that the host has gone down, too. We put that host's task back on the todo list. </p>

<p class="reference">References <a class="el" href="classMWRMComm.html#a532c61bca2f954df18a46fb4f1578606">MWRMComm::removeWorker()</a>, <a class="el" href="classMWDriver.html#a3063439d04c8048868d6c4d5c51c6778">RMC</a>, and <a class="el" href="classMWRMComm.html#acb947438d2447b15a0d621392802ff2e">MWRMComm::who()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMWDriver.html#aeb92065d166911049bec838253554555">act_on_completed_subtask()</a>, and <a class="el" href="classMWDriver.html#a7e9140329e1c6a2b4b7f1a0a9a365cab">go()</a>.</p>

</div>
</div>
<a id="a184d950e15be4aa0ecb22d7eaea622fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a184d950e15be4aa0ecb22d7eaea622fe">&#9670;&nbsp;</a></span>is_TODO_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MWDriver::is_TODO_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See whether we still have TODO tasks </p>

<p class="reference">Referenced by <a class="el" href="classMWDriver.html#a7e9140329e1c6a2b4b7f1a0a9a365cab">go()</a>, and <a class="el" href="classMWDriver.html#ab575d8dec66c8edadc165ebc6ea4e5a9">read_master_state()</a>.</p>

</div>
</div>
<a id="af6856e6de5bd17575e809e8e24140844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6856e6de5bd17575e809e8e24140844">&#9670;&nbsp;</a></span>pack_driver_task_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MWDriver::pack_driver_task_data </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>OK, This one is not pure virtual either, but if you have some "driver" data that is conceptually part of the task and you wish not to replicate the data in each task, you can pack it in a message buffer by implementing this function. If you do this, you must implement a matching unpack_worker_task_data() function. </p>

<p class="reference">Referenced by <a class="el" href="classMWDriver.html#a73290f6fab539708112ec28a9e49b563">handle_benchmark()</a>.</p>

</div>
</div>
<a id="a6a142fda8b58806b1769558afd17c85c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a142fda8b58806b1769558afd17c85c">&#9670;&nbsp;</a></span>pack_worker_init_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual MWReturn MWDriver::pack_worker_init_data </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A common theme of Master-Worker applications is that there is a base amount of "initial" data defining the problem, and then just incremental data defining "Tasks" to be done by the Workers.</p>
<p>This one packs all the user's initial data. It is unpacked int the worker class, in unpack_init_data(). </p>

<p class="reference">Referenced by <a class="el" href="classMWDriver.html#a7b1d0f044688941bd9a0e502b48c4676">handle_checksum()</a>, and <a class="el" href="classMWDriver.html#a9dc5f80c5069e9bddcfee2ad9e5e32e4">refreshWorkers()</a>.</p>

</div>
</div>
<a id="a147074c64c2bf0883077a28432816947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a147074c64c2bf0883077a28432816947">&#9670;&nbsp;</a></span>printresults()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MWDriver::printresults </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prints the Results. Applications may re-implement this to print their application specific results. It is meant to be over-ridden. </p>

<p class="reference">References <a class="el" href="classMWDriver.html#a3063439d04c8048868d6c4d5c51c6778">RMC</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMWDriver.html#a7e9140329e1c6a2b4b7f1a0a9a365cab">go()</a>.</p>

</div>
</div>
<a id="ab575d8dec66c8edadc165ebc6ea4e5a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab575d8dec66c8edadc165ebc6ea4e5a9">&#9670;&nbsp;</a></span>read_master_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MWDriver::read_master_state </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Here, you read in the 'state' of the driver from fp. Note that this is the reverse of <a class="el" href="classMWDriver.html#ab3a42409894c40f6992f01b433174588">write_master_state()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>A file pointer that has been opened for reading. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classMWDriver.html#a7d37eab370800bcc1fed37bff6c92643">gimme_a_task()</a>, <a class="el" href="classMWDriver.html#a184d950e15be4aa0ecb22d7eaea622fe">is_TODO_empty()</a>, <a class="el" href="classMWDriver.html#a033da9ddab14c10d0c174ee778234221">MIN_IN_MEM</a>, <a class="el" href="classMWDriver.html#aaa70ab2dd6087ef2415824f770747f8f">swap_in_todo_tasks()</a>, and <a class="el" href="classMWDriver.html#afa05516157b292a420ba6770fd2f493c">swap_out_todo_tasks()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMWDriver.html#af6a5b937b85d5a6cb90961249006942c">restart_from_ckpt()</a>.</p>

</div>
</div>
<a id="ad0a6b24ff90e2d2ae1495062fb480f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a6b24ff90e2d2ae1495062fb480f24">&#9670;&nbsp;</a></span>register_benchmark_task()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MWDriver::register_benchmark_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMWTask.html">MWTask</a> *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>register the task that will be used for benchmarking. </p>

</div>
</div>
<a id="af6a5b937b85d5a6cb90961249006942c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6a5b937b85d5a6cb90961249006942c">&#9670;&nbsp;</a></span>restart_from_ckpt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MWDriver::restart_from_ckpt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does the inverse of checkpoint. It opens the checkpoint file, calls <a class="el" href="classMWDriver.html#ab575d8dec66c8edadc165ebc6ea4e5a9">read_master_state()</a>, then, for each task class in the file, creates a <a class="el" href="classMWTask.html">MWTask</a>, calls read_ckpt_info on it, and adds that class to the todo list. </p>

<p class="reference">References <a class="el" href="classMWDriver.html#ad41bdc32bc2f56f7816810bc4d260db2">checkpoint()</a>, <a class="el" href="classMWDriver.html#a7d37eab370800bcc1fed37bff6c92643">gimme_a_task()</a>, <a class="el" href="classMWTask.html#ad133dd1be9c974871a1564e78eed8715">MWTask::number</a>, <a class="el" href="classMWDriver.html#a8d2aea2804ff2f999ea206a3ee0f096a">print_task_keys()</a>, <a class="el" href="classMWTask.html#a013363bc92d9ce9f0fc36fb4171b03d1">MWTask::printself()</a>, <a class="el" href="classMWRMComm.html#ac04df4ffaa419034cf0ee335cd932dcd">MWRMComm::read_checkpoint()</a>, <a class="el" href="classMWTask.html#ab370bc3712cfd33ff9a22462d62f3f0f">MWTask::read_ckpt_info()</a>, <a class="el" href="classMWDriver.html#ab575d8dec66c8edadc165ebc6ea4e5a9">read_master_state()</a>, <a class="el" href="classMWDriver.html#a3063439d04c8048868d6c4d5c51c6778">RMC</a>, <a class="el" href="classMWDriver.html#ae31fcd35f6e798994a2419db39f9f743">set_task_add_mode()</a>, <a class="el" href="classMWDriver.html#a69e6f72bc04a6c68046a41bc4292bf64">sort_task_list()</a>, <a class="el" href="classMWDriver.html#afa05516157b292a420ba6770fd2f493c">swap_out_todo_tasks()</a>, <a class="el" href="classMWDriver.html#a1d359e2a84216713f63d93ff343c68b2">task_key</a>, and <a class="el" href="classMWTask.html#af6ec7477171732f7e3a6de76a86b37a6">MWTask::write_ckpt_info()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMWDriver.html#aeb92065d166911049bec838253554555">act_on_completed_subtask()</a>, and <a class="el" href="classMWDriver.html#a7e9140329e1c6a2b4b7f1a0a9a365cab">go()</a>.</p>

</div>
</div>
<a id="aa34fc54dfba3806db87c297c8b39244a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa34fc54dfba3806db87c297c8b39244a">&#9670;&nbsp;</a></span>set_checkpoint_frequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MWDriver::set_checkpoint_frequency </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>freq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets the frequency with with checkpoints are done. It returns the former frequency value. The default frequency is zero (no checkpoints). If the frequency is n, then a checkpoint will occur after the nth call to <a class="el" href="classMWDriver.html#a920118e3f49ab81db5047d9ecdbcea2b">act_on_completed_task()</a>. A good place to set this is in <a class="el" href="classMWDriver.html#acf0edc86b06b46968114c8bb770791b2">get_userinfo()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freq</td><td>The frequency to set checkpoints to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The former frequency value. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classMWDriver.html#aeb92065d166911049bec838253554555">act_on_completed_subtask()</a>.</p>

</div>
</div>
<a id="a7f803ede53bb0d797bce81d56a33cdf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f803ede53bb0d797bce81d56a33cdf9">&#9670;&nbsp;</a></span>set_checkpoint_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MWDriver::set_checkpoint_time </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>secs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a time-based frequency for checkpoints. The time units are in seconds. A value of 0 "turns off" time-based checkpointing. Time-based checkpointing cannot be "turned 
on" unless the checkpoint_frequency is set to 0. A good place to do this is in <a class="el" href="classMWDriver.html#acf0edc86b06b46968114c8bb770791b2">get_userinfo()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">secs</td><td>Checkpoint every "secs" seconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The former time frequency value. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classMWDriver.html#aeb92065d166911049bec838253554555">act_on_completed_subtask()</a>.</p>

</div>
</div>
<a id="a97b4b046a3793d45e28bd1b2fddbd8c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b4b046a3793d45e28bd1b2fddbd8c1">&#9670;&nbsp;</a></span>set_suspension_policy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MWDriver::set_suspension_policy </td>
          <td>(</td>
          <td class="paramtype">MWSuspensionPolicy&#160;</td>
          <td class="paramname"><em>policy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the policy to use when suspending. Currently this can be either DEFAULT or REASSIGN </p>

<p class="reference">Referenced by <a class="el" href="classMWDriver.html#aeb92065d166911049bec838253554555">act_on_completed_subtask()</a>.</p>

</div>
</div>
<a id="ad41f96ba14ccc7712be09c0374eae9c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad41f96ba14ccc7712be09c0374eae9c9">&#9670;&nbsp;</a></span>set_worker_timeout_limit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MWDriver::set_worker_timeout_limit </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeout_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_frequency</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the timeout_limit and turn worker_timeout to 1 </p>

<p class="reference">References <a class="el" href="classMWTask.html#ad133dd1be9c974871a1564e78eed8715">MWTask::number</a>, and <a class="el" href="classMWTask.html#a3899784f624c803ae211ab781f180ca3">MWTask::taskType</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMWDriver.html#aeb92065d166911049bec838253554555">act_on_completed_subtask()</a>.</p>

</div>
</div>
<a id="a618bdbf6e481a903455e068ba37ba0fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a618bdbf6e481a903455e068ba37ba0fa">&#9670;&nbsp;</a></span>setup_initial_tasks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual MWReturn MWDriver::setup_initial_tasks </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMWTask.html">MWTask</a> ***&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function must return a number n &gt; 0 of pointers to Tasks to "jump start" the application.</p>
<p>The MWTasks pointed to should be of the task type derived for your application </p>

<p class="reference">Referenced by <a class="el" href="classMWDriver.html#a7e9140329e1c6a2b4b7f1a0a9a365cab">go()</a>.</p>

</div>
</div>
<a id="aaa70ab2dd6087ef2415824f770747f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa70ab2dd6087ef2415824f770747f8f">&#9670;&nbsp;</a></span>swap_in_todo_tasks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MWDriver::swap_in_todo_tasks </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_in_mem</em> = <code>256</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_in_mem</em> = <code>25600</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When swapping in, we first read first num_in_mem (or all tasks if not so many tasks in swap file) tasks from the swap file, create tasks and append to a newly created list. Then we sorted insert the existing tasks in memory into the new list. When done, switch the list and file.</p>
<p>If the old TODO list is not too small (&gt;num_in_mem), won't swap in. Return value indicates whether the swapping is successful or not. </p>

<p class="reference">References <a class="el" href="classMWDriver.html#ad41bdc32bc2f56f7816810bc4d260db2">checkpoint()</a>, <a class="el" href="classMWDriver.html#a7d37eab370800bcc1fed37bff6c92643">gimme_a_task()</a>, and <a class="el" href="classMWDriver.html#a1d359e2a84216713f63d93ff343c68b2">task_key</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMWDriver.html#ab575d8dec66c8edadc165ebc6ea4e5a9">read_master_state()</a>.</p>

</div>
</div>
<a id="afa05516157b292a420ba6770fd2f493c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa05516157b292a420ba6770fd2f493c">&#9670;&nbsp;</a></span>swap_out_todo_tasks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MWDriver::swap_out_todo_tasks </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_in_mem</em> = <code>2048</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_in_mem</em> = <code>204800</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_key</em> = <code>DBL_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TODO Tasks Swapping </p>

<p class="reference">References <a class="el" href="classMWDriver.html#ad41bdc32bc2f56f7816810bc4d260db2">checkpoint()</a>, and <a class="el" href="classMWDriver.html#a1d359e2a84216713f63d93ff343c68b2">task_key</a>.</p>

<p class="reference">Referenced by <a class="el" href="classMWDriver.html#ab575d8dec66c8edadc165ebc6ea4e5a9">read_master_state()</a>, and <a class="el" href="classMWDriver.html#af6a5b937b85d5a6cb90961249006942c">restart_from_ckpt()</a>.</p>

</div>
</div>
<a id="aaddea2ee086b0683b5d80ecb0438df91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaddea2ee086b0683b5d80ecb0438df91">&#9670;&nbsp;</a></span>unpack_worker_initinfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MWDriver::unpack_worker_initinfo </td>
          <td>(</td>
          <td class="paramtype">MWWorkerID *&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This one unpacks the "initial" information sent to the driver once the worker initializes.</p>
<p>Potential "initial" information that might be useful is... {itemize}  Information on the worker characteristics etc...  Information on the bandwith between <a class="el" href="classMWDriver.html">MWDriver</a> and worker {itemize}</p>
<p>These sorts of things could be useful in building some scheduling intelligence into the driver. </p>

<p class="reference">Referenced by <a class="el" href="classMWDriver.html#a9dc5f80c5069e9bddcfee2ad9e5e32e4">refreshWorkers()</a>.</p>

</div>
</div>
<a id="ab3a42409894c40f6992f01b433174588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a42409894c40f6992f01b433174588">&#9670;&nbsp;</a></span>write_master_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MWDriver::write_master_state </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Here you write out all 'state' of the driver to fp. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>A file pointer that has been opened for writing. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="classMWDriver.html#ad41bdc32bc2f56f7816810bc4d260db2">checkpoint()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a033da9ddab14c10d0c174ee778234221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a033da9ddab14c10d0c174ee778234221">&#9670;&nbsp;</a></span>MIN_IN_MEM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MWDriver::MIN_IN_MEM</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swap the unused part of the (sorted and indexed) TODO list onto disk (file name: TODO_tasks.id), so that the TODO tasks with smaller key values are kept in memory, and others are kept in a file. When there are too many tasks in memory, we swap most of them out; when there are too few tasks in memory, we swap in more. The MW application will be done only when all TODO tasks are done. When checkpointing, it only saves TODO tasks in memory, and the pointers (the file name) to the swap file.</p>
<p>To help swapping in tasks, we will record the number of tasks swapped in at the beginning of the file, and skip then when read to swap file. The num_to_skip is initially set to 0.</p>
<p>The swap file for TODO tasks is fully-sorted, and looks like:</p>
<p>num_to_skip trash_task1 trash_task2 ... ... task1 task2 ... ... task[num_tasks]When swapping out, we walk through the sorted TODO list, keep the first num_in_mem tasks in memory (copy into a newly created list). For the rest of the list, merge it in order with existing tasks in the file TODO_tasks, and write them into a newly created swap file. Tasks in swap file whose key values are larger than max_key are removed. When done, delete the old TODO list and swap file, switch to the new ones.</p>
<p>If the old TODO list is not too large (&lt;max_in_mem), won't swap out. Return value indicates whether the swapping is successful or not. </p>

<p class="reference">Referenced by <a class="el" href="classMWDriver.html#a5e0110a01075a9dfd3e93053b22f9ef0">MWDriver()</a>, and <a class="el" href="classMWDriver.html#ab575d8dec66c8edadc165ebc6ea4e5a9">read_master_state()</a>.</p>

</div>
</div>
<a id="a3063439d04c8048868d6c4d5c51c6778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3063439d04c8048868d6c4d5c51c6778">&#9670;&nbsp;</a></span>RMC</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMWRMComm.html">MWRMComm</a>* MWDriver::RMC</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A static instance of our Resource Management / Communication class. It's a member of this class because that way derived classes can use it easily; it's static because there should only be one instance EVER. The instance of RMC in the <a class="el" href="classMWTask.html">MWTask</a> class is actually a pointer to this one... </p>

<p class="reference">Referenced by <a class="el" href="classMWDriver.html#a0dfb4201b9bce44ba2a59019f7fc2dd2">addSortedTasks()</a>, <a class="el" href="classMWDriver.html#a8b8a9ff2699780ce52ae600b658c9e4f">addTasks()</a>, <a class="el" href="classMWDriver.html#ad41bdc32bc2f56f7816810bc4d260db2">checkpoint()</a>, <a class="el" href="classMWDriver.html#ae4c5921926e8780642d1b7dacf1a7016">delete_tasks_worse_than()</a>, <a class="el" href="classMWDriver.html#a08d81fbcaa68a8fb4ec11afcd81abc1b">get_workers_head()</a>, <a class="el" href="classMWDriver.html#a7e9140329e1c6a2b4b7f1a0a9a365cab">go()</a>, <a class="el" href="classMWDriver.html#a73290f6fab539708112ec28a9e49b563">handle_benchmark()</a>, <a class="el" href="classMWDriver.html#a7b1d0f044688941bd9a0e502b48c4676">handle_checksum()</a>, <a class="el" href="classMWDriver.html#af6c437b207bd8d327ceb84c5ce0c4304">handle_hostdel()</a>, <a class="el" href="classMWDriver.html#a0e1ef56017457e099e5947e81dd5d761">handle_hostresume()</a>, <a class="el" href="classMWDriver.html#a91c21e0a4aba8ce4e03ebf7c3064f6b5">handle_hostsuspend()</a>, <a class="el" href="classMWDriver.html#ab4ee1fc1cbc9f5e07e3083f499d29be0">handle_taskexit()</a>, <a class="el" href="classMWDriver.html#a147074c64c2bf0883077a28432816947">printresults()</a>, <a class="el" href="classMWDriver.html#a9dc5f80c5069e9bddcfee2ad9e5e32e4">refreshWorkers()</a>, <a class="el" href="classMWDriver.html#af6a5b937b85d5a6cb90961249006942c">restart_from_ckpt()</a>, and <a class="el" href="classMWDriver.html#a62ee843c55a50415b8c96c552267bd48">stop_work()</a>.</p>

</div>
</div>
<a id="a1d359e2a84216713f63d93ff343c68b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d359e2a84216713f63d93ff343c68b2">&#9670;&nbsp;</a></span>task_key</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MWKey(* MWDriver::task_key) (<a class="el" href="classMWTask.html">MWTask</a> *)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pointer to a (user written) function that takes an <a class="el" href="classMWTask.html">MWTask</a> and returns the "key" for this task. The user is allowed to change the "key" by simply changing the function </p>

<p class="reference">Referenced by <a class="el" href="classMWDriver.html#a0dfb4201b9bce44ba2a59019f7fc2dd2">addSortedTasks()</a>, <a class="el" href="classMWDriver.html#ae4c5921926e8780642d1b7dacf1a7016">delete_tasks_worse_than()</a>, <a class="el" href="classMWDriver.html#a0e1ef56017457e099e5947e81dd5d761">handle_hostresume()</a>, <a class="el" href="classMWDriver.html#a5e0110a01075a9dfd3e93053b22f9ef0">MWDriver()</a>, <a class="el" href="classMWDriver.html#a8d2aea2804ff2f999ea206a3ee0f096a">print_task_keys()</a>, <a class="el" href="classMWDriver.html#af6a5b937b85d5a6cb90961249006942c">restart_from_ckpt()</a>, <a class="el" href="classMWDriver.html#a0579cc034d3c83ea68ab456d222b8b79">return_best_running_keyval()</a>, <a class="el" href="classMWDriver.html#add3bc92ab03d051502e69ca03de4928f">return_best_todo_keyval()</a>, <a class="el" href="classMWDriver.html#abe90c9016afecc9bf9b68d4b9f3ba3b7">set_task_key_function()</a>, <a class="el" href="classMWDriver.html#a5d413e43dbd55fdc211f0aebdd51ac47">set_task_retrieve_mode()</a>, <a class="el" href="classMWDriver.html#a69e6f72bc04a6c68046a41bc4292bf64">sort_task_list()</a>, <a class="el" href="classMWDriver.html#aaa70ab2dd6087ef2415824f770747f8f">swap_in_todo_tasks()</a>, and <a class="el" href="classMWDriver.html#afa05516157b292a420ba6770fd2f493c">swap_out_todo_tasks()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="MWDriver_8h_source.html">MWDriver.h</a></li>
<li>MWDriver.C</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
